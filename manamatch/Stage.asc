// new module script
Timer* _afterTrySwap;

void Stage::Init(int numRows, int numCols, int tileSize)
{
  int width = Screen.Width;
  int height = Screen.Height;
  
  Board.Clear(this.MxPieces);
  this.MxPieces = Matrix.Create(numRows,  numCols);
  this.Board = Board.Create(Point.Create(width, height), Point.Create(numRows, numCols), this.MxPieces, tileSize);
  this.InputLayer = InputLayer.Create(this.Board.MarginLeft, this.Board.MarginTop, this.Board.RowCol_Width, this.Board.RowCol_Height, this.Board.TileSize, numRows, numCols);
  
  this.Score = Score.Create();
}

PieceType _TypeAt(Matrix* matrix, int r, int c) {
  PieceID id = matrix.GetCell(r, c);
  return Piece.GetType(id);
}

bool Stage::HasMatchAt(int row, int col)
{
  PieceID id  = this.MxPieces.GetCell(row, col);
  if ( id <= 0 ) return false;

  PieceType type = _TypeAt(this.MxPieces, row, col);
  int horzLen = 1;
  int vertLen = 1;
  
  int numCols = this.Board.NumCols;
  int numRows = this.Board.NumRows;
  
  // Verifica o máximo que consegue andar à esquerda e à direita
  // com o mesmo type
  for ( int i = col-1 ; i >= 0 && _TypeAt(this.MxPieces, row, i) == type ; i-=1) { horzLen++; }
  for ( int i = col+1 ; i < numCols && _TypeAt(this.MxPieces, row, i) == type ; i++) { horzLen++; }

  // Idem acima, para cima e para baixo
  for ( int i = row-1 ; i >= 0 && _TypeAt(this.MxPieces, i, col) == type ; i-=1) { vertLen++; }
  for ( int i = row+1 ; i < numRows && _TypeAt(this.MxPieces, i, col) == type ; i++) { vertLen++; }

  return horzLen >= 3 || vertLen >= 3;
}

IntArray* Stage::DetectMatchesInDir(MatchDirection dir)
{
  // Se dir for horizontal, então a variável I vai iterar
  // nas linhas, e J nas colunas. Se for vertical, o contrário.
  int maxIt;
  if(dir == eMD_Horizontal) maxIt = this.MxPieces.NumRows;
  else maxIt = this.MxPieces.NumCols;

  IntArray* matches = IntArray.Create();

  for ( int i = 0; i < maxIt; i++ ) {
    // A "fileira" pode ser uma linha ou coluna, e vai
    // até faltarem 2 elementos (então até end-3)
    int line[];
    int count;
    if(dir == eMD_Horizontal) {
      count = this.MxPieces.NumCols - 2;
      line = new int[count+2];
      for(int j=0; j<count+2; j++) {
        line[j] = this.MxPieces.GetCell(i, j);        
      }
    }
    else {
      count = this.MxPieces.NumRows - 2;
      line = new int[count+2];
      for(int j=0; j<count+2; j++) {
        line[j] = this.MxPieces.GetCell(j, i);
      }
    }
  
    // Para cada elemento na fileira, verifica se os próximos
    // elementos constituem um match.
    for(int j=0; j<count; ) {
      PieceType type = Piece.GetType(line[j]);
      
      // Não existe match se:
      // 1. O type estiver null (célula não existe?)
      // 2. O type de uma das próximas duas for diferente
      if ( type == ePiece_None || 
           Piece.GetType(line[j+1]) != type || 
           Piece.GetType(line[j+2]) != type )
      {
        j++;
        continue;
      }
      
      // Chega aqui se detectou um match. Pega todas as
      // células (incluindo a atual) que são do mesmo type.
      IntArray* chain = IntArray.Create();
      
      while(j<count+2 && Piece.GetType(line[j]) == type) {
        chain.Push(line[j]);
        j++; // NB: este é o contador do for()  interno
      }
      
      matches = matches.Join(chain);
    }
  }

  return matches;
}

void Stage::RemoveMatches()
{
  IntArray* hmatches = this.DetectMatchesInDir(eMD_Horizontal);
  IntArray* vmatches = this.DetectMatchesInDir(eMD_Vertical);
  
  IntArray* allCells = hmatches.Join(vmatches);
  allCells = allCells.Unique();
  
  // Se não temos matches, chegou no fim da recursão.
  if(allCells.Count < 1) return;
  
  // Computa score das peças com match
  this.Score.ScoreCellMatches(allCells);
  
  float ms = Animator.AnimateRemove(this.Board, allCells);
}

void Stage::PerformSwap(int row_a, int col_a, int row_b, int col_b)
{
  PieceID piece_a_id = this.MxPieces.GetCell(row_a, col_a);  
  PieceID piece_b_id = this.MxPieces.GetCell(row_b, col_b);
  
  Piece.SetRowCol(piece_b_id, Point.Create(row_a, col_a));
  Piece.SetRowCol(piece_a_id, Point.Create(row_b, col_b));
  
  this.MxPieces.SetCell(row_a, col_a, piece_b_id);
  this.MxPieces.SetCell(row_b, col_b, piece_a_id);
  
  // once we animate this below will go elsewhere!!!
  //Piece.SyncXYfromRowCol(piece_a_id);
  //Piece.SyncXYfromRowCol(piece_b_id);
}

void Stage::TrySwap(int from_row, int from_col, int to_row, int to_col)
{
  PieceID piece_from_id = this.MxPieces.GetCell(from_row, from_col);  
  PieceID piece_to_id = this.MxPieces.GetCell(to_row, to_col);
  
  this.PerformSwap(from_row, from_col, to_row, to_col);
  
  float duration = Animator.AnimateSwap(piece_from_id, piece_to_id);
  
  _afterTrySwap = Timer.StartRT(duration, eOnce);
}

int Stage::Render()
{
  SpriteInScreen.RenderInit();
  
  int numCols = this.MxPieces.NumCols;
  int numRows = this.MxPieces.NumRows;
  
  for(int r=0; r<numRows; r++) {
    for(int c=0; c<numCols; c++) {
      PieceID id = this.MxPieces.GetCell(r, c);
      Piece.Render(id);
    }
  }
  
  int graphic = SpriteInScreen.RenderEnd();
  
  return graphic;
}

void Stage::Update()
{
  int numCols = this.MxPieces.NumCols;
  int numRows = this.MxPieces.NumRows;
  
  for(int r=0; r<numRows; r++) {
    for(int c=0; c<numCols; c++) {
      PieceID id = this.MxPieces.GetCell(r, c);
      Piece.Update(id);
    }
  }
  
  Label1.Text = String.Format("%d, %d, %d, %d" , this.InputLayer.FromCell_Row, this.InputLayer.FromCell_Col, this.InputLayer.ToCell_Row, this.InputLayer.ToCell_Col);
  
  if(_afterTrySwap != null && !_afterTrySwap.IsActive && _afterTrySwap.RemainingTicks == 0)
  {
    _afterTrySwap = null;
    this.Score.StartChain();
    this.RemoveMatches();
  }
  
  
  if(!this.InputLayer.HasSwapped()) return;  
  
  this.TrySwap(this.InputLayer.FromCell_Row, this.InputLayer.FromCell_Col, this.InputLayer.ToCell_Row, this.InputLayer.ToCell_Col);
}

