// new module script


protected void Score::_Shake()
{
  FloatingText.Shake(this._FloatingTextID, 0.3, 5, eEaseOutBackTween, eNoBlockTween);
}

protected void Score::_SyncFloatingTextValue()
{
  FloatingText.ChangeText(this._FloatingTextID, String.Format("%06d", this._Value));  
}

void Score::_InitFloatingText()
{
  if(this._FloatingTextID > 0) return;
  this._FloatingTextID = FloatingText.New(Point.Create(this.X, this.Y), "000000", eFontbfZXout);  
}

int Score::get_Value() 
{
  return this._Value;
}

void Score::set_Value(int value) 
{
  this._Value = value;
  this._SyncFloatingTextValue();
}

bool Score::get_Visible()
{
  return this._Visible;
}

void Score::set_Visible(bool visible)
{
  this._Visible = visible;
  FloatingText.SetVisible(this._FloatingTextID, visible);
}

FloatingTextID Score::get_FloatingTextID()
{
  return this._FloatingTextID;  
}

void Score::Delete()
{
  if(this._FloatingTextID > 0) FloatingText.Delete(this._FloatingTextID);
}

void Score::SetPosition(int x, int y)
{
  this.X = x;
  this.Y = y;
  FloatingText.SetPosition(this._FloatingTextID, x, y);  
}

static Score* Score::Create(Point* position)
{
  Score* s = new Score;
  s.X = position.x;
  s.Y = position.y;
  s._InitFloatingText();
  return s;
}

void Score::StartChain()
{
  this.ChainInteraction = 1;
}

void Score::NextChain()
{
  this.ChainInteraction += 1;
}

void Score::ScoreCellMatches(IntArray* pieces) 
{
  if(pieces == null || pieces.Count <= 0) return;
  
  int iteractionPoints = 0;
  int typeCount = 0;
  int PointsPerType[ePieceMAXTYPES];
  
  for(int i=0; i<pieces.Count; i++) {
    PieceType p_type = Piece.GetType(pieces.Item[i]);
    PointsPerType[p_type] = -1;
  }
  
  for(int i=0; i<pieces.Count; i++) {
    PieceType p_type = Piece.GetType(pieces.Item[i]);
    PointsPerType[p_type] += 1;
  }
   
  for(int i=0; i<ePieceMAXTYPES; i++) {
    if(PointsPerType[i] != 0) {
      typeCount += 1;
      iteractionPoints += PointsPerType[i];
    }
  } 
  
  iteractionPoints += 2*(typeCount-1);
  
  // multiplico pontos da iteração pelo número da chain e somo no score total
  this._Value += this.ChainInteraction*iteractionPoints;
  this._SyncFloatingTextValue();
  this._Shake();
    
  // cada 'turno' de avaliação de combos, incremento o multiplicador de chain
  this.NextChain();
}